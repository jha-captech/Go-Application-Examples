// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package handlers

import (
	"context"
	"sync"

	"example.com/examples/api/layered/internal/models"
	"example.com/examples/api/layered/internal/services"
)

// Ensure that moquserCreator does implement userCreator.
// If this is not the case, regenerate this file with mockery.
var _ userCreator = &moquserCreator{}

// moquserCreator is a mock implementation of userCreator.
//
//	func TestSomethingThatUsesuserCreator(t *testing.T) {
//
//		// make and configure a mocked userCreator
//		mockeduserCreator := &moquserCreator{
//			CreateUserFunc: func(ctx context.Context, user models.User) (models.User, error) {
//				panic("mock out the CreateUser method")
//			},
//		}
//
//		// use mockeduserCreator in code that requires userCreator
//		// and then make assertions.
//
//	}
type moquserCreator struct {
	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(ctx context.Context, user models.User) (models.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User models.User
		}
	}
	lockCreateUser sync.RWMutex
}

// CreateUser calls CreateUserFunc.
func (mock *moquserCreator) CreateUser(ctx context.Context, user models.User) (models.User, error) {
	if mock.CreateUserFunc == nil {
		panic("moquserCreator.CreateUserFunc: method is nil but userCreator.CreateUser was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User models.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	return mock.CreateUserFunc(ctx, user)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//
//	len(mockeduserCreator.CreateUserCalls())
func (mock *moquserCreator) CreateUserCalls() []struct {
	Ctx  context.Context
	User models.User
} {
	var calls []struct {
		Ctx  context.Context
		User models.User
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// Ensure that moquserDeleter does implement userDeleter.
// If this is not the case, regenerate this file with mockery.
var _ userDeleter = &moquserDeleter{}

// moquserDeleter is a mock implementation of userDeleter.
//
//	func TestSomethingThatUsesuserDeleter(t *testing.T) {
//
//		// make and configure a mocked userDeleter
//		mockeduserDeleter := &moquserDeleter{
//			DeleteUserFunc: func(ctx context.Context, id uint64) error {
//				panic("mock out the DeleteUser method")
//			},
//		}
//
//		// use mockeduserDeleter in code that requires userDeleter
//		// and then make assertions.
//
//	}
type moquserDeleter struct {
	// DeleteUserFunc mocks the DeleteUser method.
	DeleteUserFunc func(ctx context.Context, id uint64) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteUser holds details about calls to the DeleteUser method.
		DeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint64
		}
	}
	lockDeleteUser sync.RWMutex
}

// DeleteUser calls DeleteUserFunc.
func (mock *moquserDeleter) DeleteUser(ctx context.Context, id uint64) error {
	if mock.DeleteUserFunc == nil {
		panic("moquserDeleter.DeleteUserFunc: method is nil but userDeleter.DeleteUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteUser.Lock()
	mock.calls.DeleteUser = append(mock.calls.DeleteUser, callInfo)
	mock.lockDeleteUser.Unlock()
	return mock.DeleteUserFunc(ctx, id)
}

// DeleteUserCalls gets all the calls that were made to DeleteUser.
// Check the length with:
//
//	len(mockeduserDeleter.DeleteUserCalls())
func (mock *moquserDeleter) DeleteUserCalls() []struct {
	Ctx context.Context
	ID  uint64
} {
	var calls []struct {
		Ctx context.Context
		ID  uint64
	}
	mock.lockDeleteUser.RLock()
	calls = mock.calls.DeleteUser
	mock.lockDeleteUser.RUnlock()
	return calls
}

// Ensure that moqhealthChecker does implement healthChecker.
// If this is not the case, regenerate this file with mockery.
var _ healthChecker = &moqhealthChecker{}

// moqhealthChecker is a mock implementation of healthChecker.
//
//	func TestSomethingThatUseshealthChecker(t *testing.T) {
//
//		// make and configure a mocked healthChecker
//		mockedhealthChecker := &moqhealthChecker{
//			DeepHealthCheckFunc: func(ctx context.Context) ([]services.HealthStatus, error) {
//				panic("mock out the DeepHealthCheck method")
//			},
//		}
//
//		// use mockedhealthChecker in code that requires healthChecker
//		// and then make assertions.
//
//	}
type moqhealthChecker struct {
	// DeepHealthCheckFunc mocks the DeepHealthCheck method.
	DeepHealthCheckFunc func(ctx context.Context) ([]services.HealthStatus, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeepHealthCheck holds details about calls to the DeepHealthCheck method.
		DeepHealthCheck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockDeepHealthCheck sync.RWMutex
}

// DeepHealthCheck calls DeepHealthCheckFunc.
func (mock *moqhealthChecker) DeepHealthCheck(ctx context.Context) ([]services.HealthStatus, error) {
	if mock.DeepHealthCheckFunc == nil {
		panic("moqhealthChecker.DeepHealthCheckFunc: method is nil but healthChecker.DeepHealthCheck was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeepHealthCheck.Lock()
	mock.calls.DeepHealthCheck = append(mock.calls.DeepHealthCheck, callInfo)
	mock.lockDeepHealthCheck.Unlock()
	return mock.DeepHealthCheckFunc(ctx)
}

// DeepHealthCheckCalls gets all the calls that were made to DeepHealthCheck.
// Check the length with:
//
//	len(mockedhealthChecker.DeepHealthCheckCalls())
func (mock *moqhealthChecker) DeepHealthCheckCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDeepHealthCheck.RLock()
	calls = mock.calls.DeepHealthCheck
	mock.lockDeepHealthCheck.RUnlock()
	return calls
}

// Ensure that moqusersLister does implement usersLister.
// If this is not the case, regenerate this file with mockery.
var _ usersLister = &moqusersLister{}

// moqusersLister is a mock implementation of usersLister.
//
//	func TestSomethingThatUsesusersLister(t *testing.T) {
//
//		// make and configure a mocked usersLister
//		mockedusersLister := &moqusersLister{
//			ListUsersFunc: func(ctx context.Context, name string) ([]models.User, error) {
//				panic("mock out the ListUsers method")
//			},
//		}
//
//		// use mockedusersLister in code that requires usersLister
//		// and then make assertions.
//
//	}
type moqusersLister struct {
	// ListUsersFunc mocks the ListUsers method.
	ListUsersFunc func(ctx context.Context, name string) ([]models.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// ListUsers holds details about calls to the ListUsers method.
		ListUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
	}
	lockListUsers sync.RWMutex
}

// ListUsers calls ListUsersFunc.
func (mock *moqusersLister) ListUsers(ctx context.Context, name string) ([]models.User, error) {
	if mock.ListUsersFunc == nil {
		panic("moqusersLister.ListUsersFunc: method is nil but usersLister.ListUsers was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockListUsers.Lock()
	mock.calls.ListUsers = append(mock.calls.ListUsers, callInfo)
	mock.lockListUsers.Unlock()
	return mock.ListUsersFunc(ctx, name)
}

// ListUsersCalls gets all the calls that were made to ListUsers.
// Check the length with:
//
//	len(mockedusersLister.ListUsersCalls())
func (mock *moqusersLister) ListUsersCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockListUsers.RLock()
	calls = mock.calls.ListUsers
	mock.lockListUsers.RUnlock()
	return calls
}

// Ensure that moquserReader does implement userReader.
// If this is not the case, regenerate this file with mockery.
var _ userReader = &moquserReader{}

// moquserReader is a mock implementation of userReader.
//
//	func TestSomethingThatUsesuserReader(t *testing.T) {
//
//		// make and configure a mocked userReader
//		mockeduserReader := &moquserReader{
//			ReadUserFunc: func(ctx context.Context, id uint64) (models.User, error) {
//				panic("mock out the ReadUser method")
//			},
//		}
//
//		// use mockeduserReader in code that requires userReader
//		// and then make assertions.
//
//	}
type moquserReader struct {
	// ReadUserFunc mocks the ReadUser method.
	ReadUserFunc func(ctx context.Context, id uint64) (models.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// ReadUser holds details about calls to the ReadUser method.
		ReadUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint64
		}
	}
	lockReadUser sync.RWMutex
}

// ReadUser calls ReadUserFunc.
func (mock *moquserReader) ReadUser(ctx context.Context, id uint64) (models.User, error) {
	if mock.ReadUserFunc == nil {
		panic("moquserReader.ReadUserFunc: method is nil but userReader.ReadUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockReadUser.Lock()
	mock.calls.ReadUser = append(mock.calls.ReadUser, callInfo)
	mock.lockReadUser.Unlock()
	return mock.ReadUserFunc(ctx, id)
}

// ReadUserCalls gets all the calls that were made to ReadUser.
// Check the length with:
//
//	len(mockeduserReader.ReadUserCalls())
func (mock *moquserReader) ReadUserCalls() []struct {
	Ctx context.Context
	ID  uint64
} {
	var calls []struct {
		Ctx context.Context
		ID  uint64
	}
	mock.lockReadUser.RLock()
	calls = mock.calls.ReadUser
	mock.lockReadUser.RUnlock()
	return calls
}

// Ensure that moquserUpdater does implement userUpdater.
// If this is not the case, regenerate this file with mockery.
var _ userUpdater = &moquserUpdater{}

// moquserUpdater is a mock implementation of userUpdater.
//
//	func TestSomethingThatUsesuserUpdater(t *testing.T) {
//
//		// make and configure a mocked userUpdater
//		mockeduserUpdater := &moquserUpdater{
//			UpdateUserFunc: func(ctx context.Context, id uint64, patch models.User) (models.User, error) {
//				panic("mock out the UpdateUser method")
//			},
//		}
//
//		// use mockeduserUpdater in code that requires userUpdater
//		// and then make assertions.
//
//	}
type moquserUpdater struct {
	// UpdateUserFunc mocks the UpdateUser method.
	UpdateUserFunc func(ctx context.Context, id uint64, patch models.User) (models.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// UpdateUser holds details about calls to the UpdateUser method.
		UpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint64
			// Patch is the patch argument value.
			Patch models.User
		}
	}
	lockUpdateUser sync.RWMutex
}

// UpdateUser calls UpdateUserFunc.
func (mock *moquserUpdater) UpdateUser(ctx context.Context, id uint64, patch models.User) (models.User, error) {
	if mock.UpdateUserFunc == nil {
		panic("moquserUpdater.UpdateUserFunc: method is nil but userUpdater.UpdateUser was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		ID    uint64
		Patch models.User
	}{
		Ctx:   ctx,
		ID:    id,
		Patch: patch,
	}
	mock.lockUpdateUser.Lock()
	mock.calls.UpdateUser = append(mock.calls.UpdateUser, callInfo)
	mock.lockUpdateUser.Unlock()
	return mock.UpdateUserFunc(ctx, id, patch)
}

// UpdateUserCalls gets all the calls that were made to UpdateUser.
// Check the length with:
//
//	len(mockeduserUpdater.UpdateUserCalls())
func (mock *moquserUpdater) UpdateUserCalls() []struct {
	Ctx   context.Context
	ID    uint64
	Patch models.User
} {
	var calls []struct {
		Ctx   context.Context
		ID    uint64
		Patch models.User
	}
	mock.lockUpdateUser.RLock()
	calls = mock.calls.UpdateUser
	mock.lockUpdateUser.RUnlock()
	return calls
}
