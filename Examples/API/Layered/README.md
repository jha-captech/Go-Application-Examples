# Layered Architecture

## Architecture Explanation

### File Structure

```text
.
├── cmd/
│   ├── api/
│   │   └── main.go                # Application entry point: server setup, DI, config loading
│   └── docs/
│       └── docs.go                # Swagger docs code generated by swaggo/swag
├── internal/
│   ├── config/
│   │   └── config.go              # Standard configuration file that reads in environment variables
│   ├── ctxhandler/
│   │   └── context_logger.go      # Sets up logger with context added
│   ├── routes/
│   │   └── routes.go              # Registers all HTTP routes and connects handlers to endpoints
│   ├── handlers/
│   │   ├── handlers.go            # Handles requests and responses
│   │   ├── response.go            # Response DTOs and output formatting
│   │   ├── read_user.go           # Handler: Get a user by ID (GET /user/{id})
│   │   ├── list_users.go          # Handler: List all users (GET /user)
│   │   ├── create_user.go         # Handler: Create a new user (POST /user)
│   │   ├── update_user.go         # Handler: Update a user by ID (PUT /user/{id})
│   │   ├── delete_user.go         # Handler: Delete a user by ID (DELETE /user/{id})
│   │   └── health.go              # Handler: Health check (GET /health)
│   ├── services/
│   │   ├── user.go                # Business logic for user operations (CRUD, deep health check, etc.)
│   │   └── cache.go               # Redis/cache abstraction, helpers, and interface
│   ├── models/
│   │   └── user.go                # Domain models/entities (e.g., User struct)
│   ├── middleware/
│   │   ├── middleware.go          # Common middleware (auth, CORS, etc.)
│   │   ├── recover.go             # Panic recovery middleware
│   │   ├── trace_id.go            # Trace ID header middleware
│   │   └── logger.go              # Request logging middleware
│   └── telemetry/
│       ├── telemetry.go           # Sets up Otel with the SDK
│       └── wrap_handler.go        # Helps create an Otel-wrapped instrumented handler
├── tests/
│   └── integration/
│       ├── integration_test.go    # Integration tests for API endpoints
│       └── helper.go              # Test helpers, test server setup, test doubles
├── go.mod                         # Go module definition
└── go.sum                         # Go dependency checksums
```

### General Notes

- Layered architecture is one of the most common Go application architectures and is arguably
  closest to the architectures used in most enterprise applications.
- The lack of domain specific names for packages is due to the project being the domain context as a
  whole.
- Layered architecture is a widely adopted pattern in Go for building scalable, maintainable, and testable applications. It separates concerns by grouping code into logical layers such as handlers (transport), services (business logic), repositories (data access), and models (domain entities).
- Each layer has a clear responsibility:
  - **Handlers** manage HTTP requests and responses, validation, and error formatting.
  - **Services** encapsulate business rules, orchestrate workflows, and coordinate between handlers and data sources.
  - **Repositories** (if present) abstract data access, making it easy to swap databases or external APIs.
  - **Models** define the core domain entities and data structures.
- This structure encourages dependency inversion: upper layers depend on interfaces, not concrete implementations, making the codebase easier to test and extend.
- The use of the internal directory in Go ensures that implementation details are hidden from external packages, promoting encapsulation and preventing accidental imports.
- Layered architecture is especially effective for applications that need to support multiple actions on a resource (CRUD), complex business logic, or integrations with external systems (databases, caches, APIs).
- While the structure is more formal than a flat or app-package approach, it provides a strong foundation for growing teams and evolving requirements, and is familiar to developers from other languages and enterprise backgrounds.
- The architecture is flexible enough to support additional cross-cutting concerns (middleware, telemetry, caching, etc.) without cluttering business logic.

### Example Applications

- **REST API Microservices**:<br>
  Ideal for services that expose multiple endpoints for CRUD operations, validation, and business rules on resources such as users, products, or orders.
- **Event-Driven Microservices**:<br>
  Suitable for applications that consume and process events from message queues or event streams, where business logic and data access are clearly separated.
- **Medium to High Complexity CLI Tools**:<br>
  Useful for command-line applications that require structured input validation, business logic, and data persistence.
- **Enterprise Applications**:<br>
  Well-suited for larger systems that require clear separation of concerns, scalability, and maintainability, such as internal business tools, admin panels, or B2B APIs.
- **Systems Integrations**:<br>
  Effective for services that need to interact with multiple external systems (databases, caches, third-party APIs) and coordinate complex workflows.
- **Prototyping for Scalable Backends**:<br>
  Provides a solid foundation for MVPs or prototypes that are expected to evolve into production-grade systems.

### Comparison

#### Pros

- **Separation of Concerns:** <br>
  Each layer has a single responsibility, making the codebase easier to understand, maintain, and test.
- **Scalability**: <br>
  The structure supports growth—new features, endpoints, or integrations can be added without major refactoring.
- **Maintainability**: <br>
  Clear boundaries between layers reduce the risk of tangled dependencies and make it easier to onboard developers who are new to Go.
- **Reusability**: <br>
  Common logic (e.g., validation, error handling, data access) can be reused across multiple handlers or services.
- **Flexibility**: <br>
  Easy to swap implementations (e.g., change database, add caching, or switch transport from HTTP to gRPC) by depending on interfaces.
- **Consistency**: <br>
  Encourages consistent patterns and practices across the codebase, reducing cognitive load and technical debt.

#### Cons

- **Overhead for Simple Apps**: <br>
  For very simple or short-lived applications, the layered approach may be overkill and slow down initial development.
- **Potential for Rigidness**: <br>
  Strict layering can make cross-cutting features or optimizations harder to implement and may encourage overly formulaic development.
- **Risk of Weak Domain Models**: <br>
  If not carefully designed, business logic may be spread too thinly across services and models, leading to less cohesive code.

## Application Usage

### Install Dependencies

These docs assume the brew is already installed on your system. For more information on installing go-task, see the instructions [here](https://taskfile.dev/installation/).

```bash
# Install Go Task
brew install go-task/tap/go-task
```

All other dependencies can be installed with:

```bash
task deps
```

### Run the Application

- Build Go App

  ```bash
  task build
  ```

- Run database and migrations

    ```bash
    task db:start
    ```

- Run the Application Locally

  ```bash
  task app:start
  ```

- Access Swagger API Docs (App needs to be running)

  Navigate to http://localhost:8080/swagger/index.html

- Stop Docker Images

  ```bash
  task docker:stop
  ```

### Working Locally

- Run Unit and Integration Tests

  ```bash
  task test:unit
  ```

- Run Integration Tests

  ```bash
  task test:integration
  ```

- Format Go Files

  ```bash
  task format
  ```

You can see other task commands that are available by running `task`